<!DOCTYPE html>
<html lang="en-us">
<head>

<script type="text/javascript" src="../../_static/js/bundle-playback.js@v=KTqwAcYd" charset="utf-8"></script>

<script type="text/javascript">
  
  

</script>
<link rel="stylesheet" type="text/css" href="../../_static/css/banner-styles.css@v=fantwOh2.css" />
<link rel="stylesheet" type="text/css" href="../../_static/css/iconochive.css@v=qtvMKcIJ.css" />
<!-- End Wayback Rewrite JS Include -->

    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="manifest" href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/manifest.json">
    <link rel="mask-icon" href="safari-pinned-tab.svg" color="#5bbad5">
    <meta name="theme-color" content="#ffffff">

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

    

<meta name="twitter:card" content="summary_large_image"/>


    
        <meta name="twitter:image" content="../../images/machinery-logo.png"/>
    
    <meta name="twitter:title" content="Simple Parallel Rendering">
    <meta name="twitter:description" content=""/>




<meta name="twitter:site" content="@ourmachinery"/>


  	<meta property="og:title" content="Simple Parallel Rendering · Our Machinery"/>
  	<meta property="og:site_name" content="Our Machinery"/>
  	<meta property="og:url" content=" ../../post/simple-parallel-rendering/"/>
    
        <meta property="og:image" content="../../images/machinery-logo.png"/>
    

    
    <meta property="og:description" content=""/>
  	<meta property="og:type" content="article"/>
    <meta property="article:published_time" content="2017-09-18T00:00:00Z"/>

    
    

    <title>Simple Parallel Rendering &middot; Our Machinery</title>

    
    <meta name="description" content=""/>
    

    <meta name="HandheldFriendly" content="True"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

    <link rel="shortcut icon" href="../../images/favicon.ico">
	  <link rel="apple-touch-icon" href="../../images/apple-touch-icon.png"/>

    <link rel="stylesheet" type="text/css" href="../../css/screen.css?v=1.1.14"/>
    <link rel="stylesheet" type="text/css" href="http://web.archive.org/web/20201215071310cs_/https://fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata"/>

    

    
        <link href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/index.xml" rel="alternate" type="application/rss+xml" title="Our Machinery"/>
    
    <meta name="generator" content="Hugo 0.37.1"/>

    <link rel="canonical" href="index.html"/>

    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//web.archive.org/web/20201215071310/https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-96359368-1', 'auto');
      

    </script>
    
</head>

    <body class="body-light">


    <link rel="stylesheet" href="../../cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
    <script src="../../cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <script type="text/javascript" src="../../js/login.js?v=1.0.10"></script>

 <div class="site-wrapper">
    <header class="site-header">
        <nav class="site-header-nav clearfix">
          
          <a class="our-machinery-logo" href="../../"><img src="../../images/full-logo.png"></a>

          <div id="menu-bar">
            <a style="color: #C7A81E;" href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/beta.html">Download Beta</a>
            
            <a href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/about.html">About</a>
            <a href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/product.html">Product</a>
            <a href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/forum.html">Forum</a>
            <a href=" ../../post/">Blog</a>
            <a class="menu-option-sign-in" href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/sign-in.html">Sign In</a>
            <a class="menu-option-sign-up" href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/sign-up.html">Sign Up</a>
            <a class="dropdown-icon menu-option-hamburger" onclick="toggleHamburgerMenu()">&#9776;</a>
            <a class="dropdown-icon menu-option-user" onclick="toggleUserMenu()"><img class="user-icon" src="../../images/user.png"/></a>
          </div>

          <div class="dropdown-menu" id="hamburger-menu">
            <a style="color: #C7A81E;" href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/beta.html">Download Beta</a>
            
            <a href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/about.html">About</a>
            <a href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/product.html">Product</a>
            <a href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/forum.html">Forum</a>
            <a href=" ../../post/">Blog</a>
            <a class="menu-option-sign-in" href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/sign-in.html">Sign In</a>
            <a class="menu-option-sign-up" href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/sign-up.html">Sign Up</a>
          </div>
         
          <div class="dropdown-menu" id="user-menu">
            <a href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/profile.html">Profile</a>
            <a href="index.html" onclick="signOut(); return false;">Sign Out</a>
          </div>
        </nav>
    </header>


<script>

function toggleDisplay(item, visibleDisplayStyle) {
  item.style.display = item.style.display != visibleDisplayStyle ? visibleDisplayStyle : "none";
}


function toggleHamburgerMenu() {
  document.getElementById("user-menu").style.display = "none";
  toggleDisplay(document.getElementById("hamburger-menu"), "block");
}


function toggleUserMenu() {
  document.getElementById("hamburger-menu").style.display = "none";
  toggleDisplay(document.getElementById("user-menu"), "block");
}


window.onclick = function(event) {
  let e = event.target;
  let hitMenu = false;
  while (e && e.classList && !hitMenu) {
    if (e.classList.contains("dropdown-menu") || e.classList.contains("dropdown-icon"))
      hitMenu = true;
    e = e.parentNode;
  }
  if (!hitMenu) {
    document.getElementById("user-menu").style.display = "none";
    document.getElementById("hamburger-menu").style.display = "none";
  }
}

initLogin();
</script>


<main class="content" role="main">

  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">Simple Parallel Rendering</h1>

        <section class="post-meta">
        
          <time class="post-date" datetime="2017-09-18T00:00:00Z">
            Sep 18, 2017
          </time>
        
         
        </section>
    </header>

    <section class="post-content">
      <p>Working on implementing the Render Graph system that I talked about in my <a href=" ../../post/high-level-rendering-using-render-graphs/">last post</a> got me thinking more about how to best feed the not-so-new-anymore graphics APIs (i.e. Vulkan and DX12) to run as efficiently as possible. So in this post and the next I will try to give some general advice on what I think is important to consider when designing a cross-platform renderer that runs on top of these APIs.</p>

<p></p>

<p>I’ve already covered the graphics API abstraction layer in the post <a href=" ../../post/a-modern-rendering-architecture/">“A Modern Rendering Architecture”</a>, so if you haven’t read it already it’s probably a good idea to do so now as that provides an overview of the low-level design of the renderer in <em>The Machinery.</em></p>

<p>In today’s post we will look at an approach for achieving data-parallelism, in a clean and simple way, when rendering large worlds generating lots of draw calls.</p>

<h2 id="parallel-rendering">Parallel rendering</h2>

<p>Rendering in general is rather straight forward to parallelize as we typically have a clean one-way data flow. If we ignore propagation of any external state changes (such as time advancement, user input, etc) we will eventually end up with having a bunch of camera frustums we want to render views from, paired with one or many sets of renderable primitives (such as meshes, particles systems, etc.) that should be rendered into these views if they somehow contribute to the final image.</p>


<figure>
    
        <img src="../../images/one-way-data-flow.png"/>
    
    
    <figcaption>
        <h4>One-way data flow.</h4>
        
    </figcaption>
    
</figure>


<p>Unless some higher level system needs feedback from the rendering there’s nothing going in the opposite direction. And even if there is, the amount of data travelling up stream is typically very limited in comparison, making it less important to design for massive throughput in that direction.</p>

<p>The key to make it simple to extract data parallelism from a rendering flow like this is to limit and plan for any kind of state mutation of the objects a head of time. This might not be a problem even if you think about the frame flow in a very serial manner, e.g:</p>

<ol>
<li>Cull light sources against main camera frustum.</li>
<li>For each shadow casting light source.

<ol>
<li>Cull shadow caster against light camera frustum.</li>
<li>Render visible shadow casting renderables.</li>
</ol></li>
<li>Cull renderables against main camera frustum.</li>
<li>Render visible renderables.</li>
<li>..and so on until everything has been rendered..</li>
</ol>

<p>However there are at least two problematic scenarios to consider with this approach:</p>

<ol>
<li>What if you want to skip evaluating some computation or updating some resource based on the culling result, i.e. if the renderable is visible or not. Example: calculation of skinning matrices.</li>
<li>What if you have a resource that wants different state depending on camera location. Example: LOD of a particle system.</li>
</ol>

<p>In both these scenarios the problem is that the state of the objects needs to mutate based on the result of the culling and/or location of cameras. And this state mutation happens while any number of jobs might be visiting the same object. If you follow something similar to the naive serial breakdown described above and don’t plan for this, the code easily becomes complex and inefficient due to the various state tracking mechanisms that needs to be put in place in both the renderer as well as the render backends to guarantee object consistency.</p>

<p>To better explain this let’s take a closer look at the second scenario from the example above. Let’s consider a particle system that wants different geometry representations based on camera position due to some kind of Level-Of-Detail mechanism. Now, let’s assume that this particle system will be rendered using a material that writes into two different layers when viewed from the main camera, say e.g. the “g-buffer” layer and “emissive” layer. On top of that it also casts shadows and the shadows happens to be configured to render in between the g-buffer and emissive layers. In this case you end up with something like this in the back-end:</p>

<ol>
<li>Render from main camera into g-buffer render targets, geometry state 0</li>
<li>Render from shadow camera 0 into shadow map, geometry state 1</li>
<li>Render from shadow camera 1 into shadow map, geometry state 2 (and so on for each shadow camera)</li>
<li>Render from main camera into emissive render target, geometry state 0</li>
</ol>

<p>Implementing state management for something like this easily becomes messy, especially when everything is running in parallel.</p>

<h2 id="a-cleaner-approach">A cleaner approach</h2>

<p>Fortunately there’s a straight forward and simple solution to this, well — at least if you are writing a renderer from scratch, retrofitting this approach to an existing large code base would probably be a bigger challenge.</p>

<p>The core idea is to simply stop visiting the same renderable object more than once per frame. If we can guarantee that no one else is visiting the same object at the same time we can also safely mutate its state. To achieve this you’ll need a mechanisms that allows you to completely decouple GPU scheduling of draw calls / state changes from CPU scheduling. We do this using a 64 bit sort key that we pair with every render command, I’ve covered this before [<a href=" ../../post/high-level-rendering-using-render-graphs/">2</a>] so I won’t go into any details how its done. However it’s important to understand that it is crucial to have something like this in place or else you are stuck in some kind of semi-immediate mode that makes implementing this approach much more complicated than it has to be.</p>

<p>The way to structure your code is to have each system in need of rendering various objects (i.e. systems for <em>regular object rendering, shadow mapping, cube map generation</em>, <em>etc</em>) expose an interface for retrieving what cameras it wants to render from, what set of renderable objects each camera is interested in, and optional sort keys for each camera.</p>

<p>When all the viewing cameras have been gathered we associate each camera with a bit in an arbitrary long bit mask controlled by the culling system. We then run the culling system for all object sets against all interested camera frustums. Exactly how this is implemented doesn’t really matter as long as you end up with having an output from the culling system where each object holds the visibility result per camera represented as a bit in a bit mask.</p>

<p>We then filter the output from the culling system to eliminate all objects from the list not intersecting any camera frustums. What we end up with is a <em>unique</em> list of renderable objects that intersects one or many of the cameras. By looking at the number of intersecting cameras and having an understanding of the computational complexity of the various types of renderable objects we can derive some kind of load balancing metric for how to split the list of renderable objects into well balanced jobs (i.e. we are striving for our jobs to take approximately the same time to execute).</p>

<p>Within the jobs we then call the render function on each object and pipe in an array of cameras with optional sort keys as parameter. As we now can be certain that no other jobs are touching the state of the object we can safely mutate its state and update any resources (skin matrices, geometry, whatnot) that might be in need of updating.</p>

<p>By restructuring our code like this we not only solve the state tracking issues when updating resources, we also make sure to never visit a renderable object more than once per frame making this approach more cache friendly than a more traditional serial approach where you typically end up visiting the same object multiple times during a frame. At the same time, we also made it easier for people plugging in new types of renderable objects into the platform as they no longer have to guarantee that their render callbacks are state immutable.</p>

<h2 id="next-time">Next time</h2>

<p>Next time we will look at some things related to various render state changes that we do in our <code>tm_renderer_command_buffer_i</code> interface to make it map nicely to Vulkan and DX12.</p>
    </section>


  <footer class="post-footer">

    


<section class="author">
  <h4><a href="../../">Tobias Persson</a></h4>
</section>



    
<section class="share">
  <h4>Share this post</h4>
  <a class="icon-twitter" style="font-size: 1.2em" href="http://web.archive.org/web/20201215071310/https://twitter.com/share?text=Simple%20Parallel%20Rendering - Our%20Machinery&amp;url=https%3a%2f%2fourmachinery.com%2fpost%2fsimple-parallel-rendering%2f" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
      <span class="hidden">Twitter</span>
  </a>
  <a class="icon-facebook" style="font-size: 1.2em" href="http://web.archive.org/web/20201215071310/https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fourmachinery.com%2fpost%2fsimple-parallel-rendering%2f" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
      <span class="hidden">Facebook</span>
  </a>
  <a class="icon-pinterest" style="font-size: 1.2em" href="http://web.archive.org/web/20201215071310/https://pinterest.com/pin/create/button/?url=https%3a%2f%2fourmachinery.com%2fpost%2fsimple-parallel-rendering%2f&amp;description=Simple%20Parallel%20Rendering" onclick="window.open(this.href, 'pinterest-share','width=580,height=296');return false;">
      <span class="hidden">Pinterest</span>
  </a>
</section>



  </footer>

  <br clear="all"/>

  




</article>

</main>
    <footer class="site-footer clearfix body-dark">
        <section class="copyright">&copy; <a href="index.html">Our Machinery</a>  2020</section>

        <a class="site-footer-icon" href="http://web.archive.org/web/20201215071310/https://twitter.com/ourmachinery" target="_blank">
            <span class="icon-twitter"></span>
        </a>

        <a class="site-footer-icon" href="http://web.archive.org/web/20201215071310/https://www.facebook.com/Our-Machinery-1828502157362699" target="_blank">
            <span class="icon-facebook"></span>
        </a>    
    
        <a class="site-footer-icon" href="http://web.archive.org/web/20201215071310/https://instagram.com/ourmachinery" target="_blank">
            <span class="icon-instagram"></span>
        </a>

        <a class="site-footer-icon" href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/index.xml" target="_blank">
            <span class="icon-feed"></span>
        </a>

        <a class="site-footer-icon" href="http://web.archive.org/web/20201215071310/https://ourmachinery.com/cdn-cgi/l/email-protection#25554c4b42654a50574844464d4c4b40575c0b464a48" target="_blank">
            <span class="icon-mail"></span>
        </a>
    </footer>
    </div> 
<script data-cfasync="false" src="http://web.archive.org/web/20201215071310js_/https://ourmachinery.com/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body>
</html>

<!--
     FILE ARCHIVED ON 07:13:10 Dec 15, 2020 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 00:53:30 Aug 01, 2022.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 253.128
  exclusion.robots: 0.109
  exclusion.robots.policy: 0.1
  cdx.remote: 0.074
  esindex: 0.01
  LoadShardBlock: 119.492 (3)
  PetaboxLoader3.datanode: 118.371 (4)
  CDXLines.iter: 16.529 (3)
  load_resource: 46.312
  PetaboxLoader3.resolve: 25.323
-->