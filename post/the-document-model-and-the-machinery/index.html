<!DOCTYPE html>
<html lang="en-us">
<head>

<script type="text/javascript" src="../../_static/js/bundle-playback.js@v=KTqwAcYd" charset="utf-8"></script>

<script type="text/javascript">
  
  __wm.wombat("http://ourmachinery.com:80/post/the-document-model-and-the-machinery/","20180423044956","http://web.archive.org/","web"../../_static/",

</script>
<link rel="stylesheet" type="text/css" href="../../_static/css/banner-styles.css@v=fantwOh2.css" />
<link rel="stylesheet" type="text/css" href="../../_static/css/iconochive.css@v=qtvMKcIJ.css" />
<!-- End Wayback Rewrite JS Include -->


    <link rel="apple-touch-icon" sizes="180x180" href="http://web.archive.org/web/20180423044956im_/http://ourmachinery.com/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="http://web.archive.org/web/20180423044956im_/http://ourmachinery.com/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="http://web.archive.org/web/20180423044956im_/http://ourmachinery.com/favicon-16x16.png">
    <link rel="manifest" href="http://web.archive.org/web/20180423044956/http://ourmachinery.com/manifest.json">
    <link rel="mask-icon" href="http://web.archive.org/web/20180423044956im_/http://ourmachinery.com/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="theme-color" content="#ffffff">

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

    

<meta name="twitter:card" content="summary_large_image"/>


    
        <meta name="twitter:image" content="http://web.archive.org/web/20180423044956im_/http://ourmachinery.com/images/editor.png"/>
    
    <meta name="twitter:title" content="The Document Model and The Machinery">
    <meta name="twitter:description" content="The choices we face when trying to create a Document Model for The Machinery."/>




<meta name="twitter:site" content="@ourmachinery"/>


  	<meta property="og:title" content="The Document Model and The Machinery · Our Machinery"/>
  	<meta property="og:site_name" content="Our Machinery"/>
  	<meta property="og:url" content="http://web.archive.org/web/20180423044956/http://ourmachinery.com/post/the-document-model-and-the-machinery/"/>
    
       <meta property="og:image" content="http://web.archive.org/web/20180423044956im_/http://ourmachinery.com/images/editor.png"/>
    

    
    <meta property="og:description" content="The choices we face when trying to create a Document Model for The Machinery."/>
  	<meta property="og:type" content="article"/>
    <meta property="article:published_time" content="2018-02-18T00:00:00Z"/>

    
    

    <title>The Document Model and The Machinery &middot; Our Machinery</title>

    
    <meta name="description" content="The choices we face when trying to create a Document Model for The Machinery."/>
    

    <meta name="HandheldFriendly" content="True"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

    <link rel="shortcut icon" href="http://web.archive.org/web/20180423044956im_/http://ourmachinery.com/images/favicon.ico">
	  <link rel="apple-touch-icon" href="http://web.archive.org/web/20180423044956im_/http://ourmachinery.com/images/apple-touch-icon.png"/>

    <link rel="stylesheet" type="text/css" href="http://web.archive.org/web/20180423044956cs_/http://ourmachinery.com/css/screen.css?v=1.0.0"/>
    <link rel="stylesheet" type="text/css" href="http://web.archive.org/web/20180423044956cs_/http://ourmachinery.com/css/nav.css"/>
    <link rel="stylesheet" type="text/css" href="http://web.archive.org/web/20180423044956cs_/http://fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400|Inconsolata"/>

    

    
        <link href="http://web.archive.org/web/20180423044956/http://ourmachinery.com/index.xml" rel="alternate" type="application/rss+xml" title="Our Machinery"/>
    
    <meta name="generator" content="Hugo 0.37.1"/>

    <link rel="canonical" href="index.html"/>

    
      
    
    <script type="application/ld+json">
{
    "@context": "http://web.archive.org/web/20180423044956/https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": 
    },
    "author": {
        "@type": "Person",
        "name": ,
        
        "url": ,
        "sameAs": [
            
            
             
             
             
             
             
            
        ]
    },
    "headline": The Document Model and The Machinery,
    "name": The Document Model and The Machinery,
    "wordCount": 3520,
    "timeRequired": "PT17M",
    "inLanguage": {
      "@type": "Language",
      "alternateName": en
    },
    "url": http://ourmachinery.com/post/the-document-model-and-the-machinery/,
    "datePublished": 2018-02-18T00:00Z,
    "dateModified": 2018-02-18T00:00Z,
    
    "image": {
        "@type": "ImageObject",
        "url": http://ourmachinery.com/editor.png,
        "width": 3000,
        "height": 1445
    },
    
    "keywords": ,
    "description": The choices we face when trying to create a Document Model for The Machinery.,
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": http://ourmachinery.com/post/the-document-model-and-the-machinery/
    }
}
    </script>
    


    

    
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//web.archive.org/web/20180423044956/http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-96359368-1', 'auto');
      

    </script>
    
</head>

    <body class="body-light">


    <link rel="stylesheet" href="http://web.archive.org/web/20180423044956cs_/http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/default.min.css">
    <script src="http://web.archive.org/web/20180423044956js_/http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

 <div class="site-wrapper">

    <header class="main-header">
        <nav class="main-nav overlay clearfix">
            <a class="blog-logo" href="http://web.archive.org/web/20180423044956/http://ourmachinery.com/"><img src="http://web.archive.org/web/20180423044956im_/http://ourmachinery.com/images/full-logo.png"/></a>
    
           
            <a class="menu-button" href="http://web.archive.org/web/20180423044956/http://ourmachinery.com/post/">Blog</a>
        </nav>
    </header>



<main class="content" role="main">

  <article class="post post">

    <header class="post-header">
        <h1 class="post-title">The Document Model and The Machinery</h1>

        <section class="post-meta">
        
          <time class="post-date" datetime="2018-02-18T00:00:00Z">
            Feb 18, 2018
          </time>
        
         
        </section>
    </header>

    <section class="post-content">
      <p>Since my last few blog posts have been rummaging around at a pretty low level, let’s try something different this week and lift our gaze high, high — almost all the way to the top, to something that we refer to as the <em>Document Model</em>.</p>

<p></p>

<p>I’m not sure if anyone else is using this term too, or if there is another, more commonly used word for this thing. I just remember having these (somewhat heated) discussions a couple of years ago. We were clearly arguing about <em>something,</em> but it didn’t seem to have a good name, so we just started calling it the <em>Document Model</em>.</p>

<p>By the <em>Document Model</em> we mean the way documents, save/revert, undo/redo and window layout interoperate to provide an editing experience for the user. Note that we are not interested in how anything is implemented (that’s for later), just how things hang together conceptually. Any application that allows the user to create and edit things has some kind of <em>Document Model</em>.</p>

<p>This may seem suuuper abstract at this point, so let’s look at some concrete examples:</p>

<p><em>Microsoft Word</em> has a pretty typical old-school document model. You have a file on disk. When you double-click it, it opens in a new window. In that window, you can edit it, undo/redo, save it back to disk or revert it. The undo stack is unlimited (or at least really big), but it is not saved with the document, so if you close your window you lose the possibility to undo.</p>

<p>For something radically different, consider a To-Do list app for your phone. Here, there is no concept of opening a document, you are just immediately editing (creating tasks and checking them off). Since there are no “documents” there is also no concept of “saving” or “reverting” — you just expect the data to somehow be automatically persisted for you and be there the next time you open the app. There is also (typically) no undo or redo functionality.</p>

<p>And between these two extremes there is a plethora of other possibilities.</p>

<p>In the document model we also count the way windows and tabs behave. Are there different kinds of windows — like regular windows and floating “tool” windows? What can be docked where? When do we open new windows? Etc. Version control is another important part of the document model — for any project that involves multiple people.</p>

<p>The Document Model for something like a game editor can be pretty complex, because game editors deal with a lot of stuff. They typically have an <em>Asset Browser</em> or similar that let’s the user navigate between thousands of different resources with different editors and tools. How do we keep all that consistent and usable?</p>

<p>In the low-level world, where I like to spend a lot of my time, you can often find answers that are <em>right</em>, or at least <em>right-ish</em>. After all, you can always benchmark your code to see what runs faster. But up here in Document Model Land, things are a lot more loosey-goosey.</p>

<p>So it’s not that one document model is right or wrong, rather we have <em>choices</em>. And the choices have <em>consequences</em>. In this post I’ll try to map out some of these choices and their consequences as they apply to our world of 3D scene/simulation/game editing. I’ll also talk a bit about some of the choices we’ve made for The Machinery, though a lot remains unanswered.</p>

<p>Let’s begin!</p>

<h2 id="saving-projects-or-individual-assets">Saving: Projects or Individual Assets</h2>

<p>A 3D world is typically built up from a collection of distinct, but interconnected, assets: models, textures, particle effects, scenes, etc. When designing a saving model, you can either focus on the distinctness or the interconnectedness. There are three basic approaches you can take:</p>

<ol>
<li><p>Assets are saved/reverted individually. I.e. you edit a specific scene/texture/model and when you are done, you save that particular thing.</p></li>

<li><p>Saves are done on the project level. I.e. you can’t save changes to an individual model or texture, you can only save or revert the entire project.</p></li>

<li><p>There are no explicit save or revert operations. Changes are always permanent (persisted automatically for the user).</p></li>
</ol>

<p><em>Visual Studio</em> is an example of model 1. Source code files are saved and reverted individually, even though they’re all a part of the same project. <em>Powerpoint/Keynote</em> could be considered as model 2. Even though a presentation has multiple individual parts (images, film clips, etc) it’s all saved as a single thing. Finally, <em>Google Docs</em> and the <em>Calendar</em> app are using model 3. Your changes are saved automatically without any explicit save step.</p>

<p>Going from 1 → 2 → 3 we are trading explicit control for convenience and “not having to think about it”. Modern phone and web apps tend to increasingly favor model 3. Why should the user have to worry about when things are saved when it can be taken care of automatically?</p>

<p>Many desktop programs are also secretly implementing model 3 behind the scene, even if they seem to be using model 1 on the surface. You can see this when you restart the program after a crash and it asks you if you want to “recover” the files you where working on — it was saving them all along!</p>

<p>Are there any advantages at all to explicit saving? I can see two:</p>

<ol>
<li><p>It explicitly indicates that the file is ready for sharing with other programs. I.e. you can attach it to an email or check it in to source control. When working in a large project together with other people, it is important to know exactly what has changed, when and why. Source control can do this too — you see what files you’ve changed when you check in, but it’s nice to be explicit about this. Furthermore, since source control works on a file-by-file basis, it maps a bit better to model 1.</p></li>

<li><p>It gives you a “checkpoint” that you can go back to (by reverting or discarding changes). This allows you to play around a bit more without worrying that you will destroy your work, because you can always go back to the “checkpoint”. Model 1 allows you to checkpoint individual assets, while model 2 only allows you to checkpoint the project as a whole. Source control can do this too, but in a more complicated way.</p></li>
</ol>

<p>It is possible to implement checkpoints in model 3 too. We could have a menu option that allows the user to create one (or more) checkpoints that they can revert to later. But since users aren’t that familiar to this new “checkpoint” concept we just invented, maybe we should just call the operation “Save” instead of “Create Checkpoint”. Now we’re back to implementing model 3, but disguising it as model 2.</p>

<p>Model 1 gives us individual checkpoints for each asset, while model 2 only gives us a checkpoint for the entire project. Individual asset checkpoints can be useful, but when the assets are interdependent they can also create inconsistencies.</p>

<p>For example, suppose that you add a bone to a model asset, and then an animation for that bone to an animation asset. Then you revert the model, but not the animation. Now you have an animation for a bone that doesn’t exist — an inconsistency.</p>

<p>Inconsistencies like these are kind of common in applications that use model 1. For example, in <em>Visual Studio</em> (our model 1 example) they can show up as compile errors, linker errors or missing project files. If you are building a model 1 application where there are dependencies between the assets you will face similar issues. You have to make sure your application has a way of displaying inconsistencies, such as missing files or references, and a way of resolving them.</p>

<p>All this extra error handling can be a lot of work, so we might be tempted to prevent it by using model 2. It would seem that with model 2, the application is always in control and can prevent inconsistencies from happening.</p>

<p>Unfortunately, if you want to use version control to collaborate with others the application is <em>not</em> in control and inconsistencies can still happen. Even if you use model 2 and save all files at the same time, the version control software can still update, commit, merge and revert files individually. This can cause the exact same inconsistencies that you can get with model 1 and the revert operation. It might even be a bit trickier, since the saves are now less obvious. So you can’t get away from the inconsistencies, your program will just have to deal with them.</p>

<p>A side note about collaboration: AFAIK, the latest versions of <em>Keynote</em> will actually break down your slides into multiple individual pieces when they’re saved to iCloud, so that multiple people can work in the same document without causing conflicts (as long as they work on different pieces). So in a way, <em>Keynote</em> is a model 1 program, posing as model 2!</p>

<p>Oh, and one more thing. Whenever you are faced with a tricky UI decision like which save model to use, there will always be someone who says “why don’t we implement both and leave it up to the user as a configuration setting”. I think that’s a cop-out and hardly ever the right decision. It’s hard enough to make one workflow run smoothly, if you have thousands of different possible workflows based on different setting flag combinations, none of them will be great. It also fragments the user base and makes it harder to follow tutorials (because the tutorial might use different settings than you). Don’t be afraid to take a stance. Applications should be opinionated! At least that’s my opinion.</p>

<h2 id="undo-and-redo">Undo and Redo</h2>

<p>The choice between a Projects viewpoint and an Assets viewpoint pops up again when you start looking at Undo and Redo. The Project approach is to have a single undo stack for the entire application. Any operation you perform ends up on that stack. The Individual Asset approach is to give each document its own undo stack. When you undo, you undo changes to that particular document.</p>

<p>Typically the Undo model follows the Save model, so if assets are saved individually they also have individual undo stacks. You can see this for example in <em>Visual Studio</em>. You can make some changes in <code>a.cpp</code>, make some other changes in <code>b.cpp</code>, then go back to <code>a.cpp</code> and undo the changes you did there without affecting <code>b.cpp</code>. With a shared undo stack, you would have to undo all the changes to <code>b.cpp</code> before you could get to the earlier changes you made to <code>a.cpp</code>.</p>

<p>I sometimes take advantage of these multiple undo stacks — i.e., go back and undo an older change in a different file — but it is a pretty rare occasion. I don’t know if that’s just me though. Do you ever use this feature, or do you mostly just undo your most recent changes?</p>

<p>Having multiple separate undo stacks can be problematic. With separate undo stacks per asset, any operation that affects multiple assets cannot be undone as a single operation. You can see this in <em>Visual Studio</em> with <em>Find &amp; Replace</em>. Suppose you do a find-and-replace that replaces <code>foo</code> with <code>bar</code> in 200 files. Since there is no global undo stack, that operation has to go into the undo stack of each one of those individual documents. And if you want to undo it, you have to go into each document and undo the change there. That gets pretty tedious.</p>

<p>Another example: renaming a file is not an undoable action in Visual Studio. This makes sense, because it is not clear what undo stack that rename operation should go into. If we had a single project-wide undo stack, on the other hand, both <em>Find &amp; Replace</em> and <em>Rename</em> could be undoable actions.</p>

<p>When files have interdependencies, multiple undo stacks can lead to the same inconsistencies as the revert operation we talked about earlier. We can use the same example as before. Suppose you create a bone and an animation and undo the creation of the bone, but leave the animation there. Now there is an animation for a bone that doesn’t exist.</p>

<p>If there is only a single undo stack, undoing will always take you back to a previous state of the project, so weird surprises like this can’t happen.</p>

<p>A single undo stack can be surprising in other ways though. Suppose you open a material asset, work on that for a bit, save the project and close it. Then you open a scene asset and start working on that. Now if you press undo too many times you will start undoing the changes you made in the material file. Moreover, since you’ve closed the material window there is no on-screen indication of what is happening. (Unless you consider the opening and closing of windows undoable operations too, in which case windows would pop up and disappear as you kept undoing. This is weird in a different way.)</p>

<p>Side note: If you are into collaborative editing (which, full disclosure, I am) even if you go with a unified undo stack, multiple undo stacks will creep back into your life again, because each user needs their own undo stack. Otherwise, a user couldn’t undo their changes without risking undoing changes made by other users, which would be super weird. This mirrors what we saw for save and revert. There, we thought we got rid of the inconsistencies, but they crept back through collaboration (via version control software). Here, online collaboration puts us at risk for undo inconsistencies.</p>

<h2 id="tabs-windows">Tabs &amp; Windows</h2>

<p>Another important part of the Document Model is how tabs and windows work. Again, this is something that may not seem like a big deal, but in a game editor things can quickly get out of hand with different editors, tool panels, properties, message logs, etc, etc:</p>


<figure>
    
        <img src="http://web.archive.org/web/20180423044956im_/http://ourmachinery.com/images/editor.png"/>
    
    
    <figcaption>
        <h4>A typical editor window.</h4>
        
    </figcaption>
    
</figure>


<p>The questions you face when designing the window system are things like:</p>

<ul>
<li>Are there different <em>kinds</em> of windows? Is the <em>Animation Editor</em> a different kind of window than the <em>Scene Editor?</em></li>
<li>Is the <em>Asset Browser</em> a window, a tab, or both?</li>
<li>Can you drag tabs from one kind of window to another?</li>
<li>Where do you put menu bars? In the tabs or in the windows? Or only in the main window? Is there a main window, by the way? What makes the main window different from other windows? If you close the main window, does the application shut down or does another window become the main window?</li>
<li>Are there tabs and child tabs? Is the <em>Properties</em> tab a child of the <em>Scene</em> tab since it displays the properties of objects in the <em>Scene</em> tab? Does this mean the <em>Properties</em> tab should be closed if the <em>Scene</em> tab is closed? Should the <em>Properties</em> tab in fact be docked <em>inside</em> the <em>Scene</em> tab so we have nested levels of tabs? Do we need multiple levels of nesting?</li>
<li>When we open a scene for editing does it open a new window with multiple tabs, or just a new tab, or do we reuse an existing tab?</li>
</ul>

<p>There are a lot of different possible approaches. For Stingray we designed a solution with “big tabs” and “small tabs”. “Big tabs” where full-sized editors with menu bars that could be docked in windows. “Small tabs” where smaller auxiliary tabs that where docked inside the big tabs. It ended up being pretty complicated and was never fully implemented.</p>

<p>For The Machinery we wanted a simpler approach, so we started with a few basic rules:</p>

<ul>
<li>Everything is a tab.</li>
<li>All the tabs are on an equal footing — there are no child tabs and parent tabs, big tabs and small tabs.</li>
<li>The user can create as many tabs as they want of any particular type. There can be multiple <em>Properties</em> tabs, multiple <em>Asset Browser</em> tabs, etc.</li>
<li>Tabs can be freely moved around, docked and arranged in windows any way the user likes.</li>
<li>Windows don’t have any meaning by themselves — they are defined by the tabs that are docked there. You can create a window out of any combination of tabs.</li>
<li>All the windows are on an equal footing — there is no “main” window. Every window has a menu bar. The content of the menu bar is defined by the tabs that are docked in the window.</li>
</ul>

<p>So for example, if the <em>Profiler</em> tab is docked in a window, that window’s menu bar will get a <em>Profiler</em> menu. The tabs “carry” their menus with them and “dock” them in the window where they are docked.</p>

<p>An important piece of the puzzle is how we handle dependencies between tabs. For example, the <em>Asset Preview</em> tab depends on the <em>Asset Browser</em> tab, because it should show a preview of the asset that is currently selected in the browser. How do we handle this without introducing a “child tab” concept when there can be multiple <em>Asset Previews</em> and <em>Asset Browsers</em> open?</p>

<p>Our solution is to define this relationship implicitly. Instead of permanently storing and keeping track of the parent-child relationship between tabs we determine it at runtime, when a tab is rendered. (This is where it helps to have an IMGUI based system.)</p>

<p>The way it works is this: When it’s time for the <em>Asset Preview</em> to render it checks the window it is currently docked in to find an <em>Asset Browser</em> there. If it finds one, it shows a preview of the currently selected asset in that browser. If there are multiple <em>Asset Browsers</em> docked in the window, it shows the preview of whichever one the user last interacted with. We assume that this is the one the user wants to see.</p>

<p>If there is no <em>Asset Browser</em> docked in the same window we look for the last <em>Asset Browser</em> interacted with in <em>any</em> window. If we don’t find any asset browser at all, the preview is blank. Note that this means that if you move the <em>Asset Preview</em> from one window with an *Asset Browse*r to another, the <em>Asset Preview</em> will change to show the selected asset in the other window.</p>

<p>The <em>Properties</em> tab works the same way, but instead of just looking for the <em>Scene</em> tab we look for <em>any</em> tab that wants to display properties of objects. This way we can reuse the same <em>Properties</em> tab for multiple things. For example, when an object is selected in the asset browser, the <em>Properties</em> tab can show the properties of that asset. This helps keep the number of windows down which reduces the tab/window management that the user has to deal with. Other helper windows, such as the <em>Tree</em> or <em>Help</em> can also be reused in the same way.</p>

<p>In the future we’ll probably implement some way of “locking” and “unlocking” the connection between the tabs, so that you can keep the <em>Asset Preview</em> focused on one <em>Asset Browser</em> regardless of how you move it around, if you want to.</p>

<p>There is a bit of interaction between the window model and the save model. In save model 1, open windows are typically used to represent unsaved files and when you close the window you will be asked if you want to save the changes. Having this one-to-one correspondence between changed documents and open windows means that if you do something that changes a bunch of documents you also <em>have to</em> open windows corresponding to all those documents. This is why in Visual Studio, if you do a search-and-replace across multiple files, all those files will be opened.</p>

<p>There are situations where this model works really badly. For example, suppose that one of our assets is an <em>Entity Prototype</em>, and suppose we have an operation in the <em>Scene</em> editor that allows us to place a prototype in the scene, make some changes to it and then save them back to the prototype, so that they apply to all instances of the prototype. If we have the rule that every modified document must correspond to an open window, that “save back” operation has to open a window for the prototype asset, which feels pretty weird.</p>

<p>Another situation where this doesn’t work so well is if you allow the <em>Properties</em> editor to work directly on assets. I.e., if you can select one (or more) assets in the asset browser, see some properties for them in the <em>Properties</em> window and modify them. Now we would have to open editing windows for all those assets.</p>

<p>Of course, it is possible to use save model 1 without requiring every modified asset to have an open window. We could just keep all the modified assets in a list somewhere. This means that changes will not actually be lost when a window is closed. So should we still ask the user to save the changes?</p>

<h2 id="conclusions">Conclusions</h2>

<p>At this point we’re pretty happy with the way windows and tabs work, but we are still weighing the pros and cons of the different save and undo models. Is being more explicit about exactly what files are being changed and when worth the risk of inconsistencies and non-undoable actions? Stay tuned, and let me know your opinions at <a href="http://web.archive.org/web/20180423044956/https://twitter.com/niklasfrykholm">@niklasfrykholm</a>.</p>
    </section>


  <footer class="post-footer">


    

    





<section class="author">
  <h4><a href="http://web.archive.org/web/20180423044956/http://ourmachinery.com/">Niklas Gray</a></h4>
  
  
  <div class="author-meta">
    
    
  </div>
</section>



    
<section class="share">
  <h4>Share this post</h4>
  <a class="icon-twitter" style="font-size: 1.2em" href="http://web.archive.org/web/20180423044956/https://twitter.com/share?text=The%20Document%20Model%20and%20The%20Machinery - Our%20Machinery&amp;url=http%3a%2f%2fourmachinery.com%2fpost%2fthe-document-model-and-the-machinery%2f" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
      <span class="hidden">Twitter</span>
  </a>
  <a class="icon-facebook" style="font-size: 1.2em" href="http://web.archive.org/web/20180423044956/https://www.facebook.com/sharer/sharer.php?u=http%3a%2f%2fourmachinery.com%2fpost%2fthe-document-model-and-the-machinery%2f" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
      <span class="hidden">Facebook</span>
  </a>
  <a class="icon-pinterest" style="font-size: 1.2em" href="http://web.archive.org/web/20180423044956/http://pinterest.com/pin/create/button/?url=http%3a%2f%2fourmachinery.com%2fpost%2fthe-document-model-and-the-machinery%2f&amp;description=The%20Document%20Model%20and%20The%20Machinery" onclick="window.open(this.href, 'pinterest-share','width=580,height=296');return false;">
      <span class="hidden">Pinterest</span>
  </a>
  <a class="icon-google-plus" style="font-size: 1.2em" href="http://web.archive.org/web/20180423044956/https://plus.google.com/share?url=http%3a%2f%2fourmachinery.com%2fpost%2fthe-document-model-and-the-machinery%2f" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
      <span class="hidden">Google+</span>
  </a>
</section>



    


  </footer>
</article>

</main>
    <footer class="site-footer clearfix body-dark">
        <section class="copyright">&copy; <a href="index.html">Our Machinery</a> 2018</section>

        <a class="bloglogo" href="http://web.archive.org/web/20180423044956/https://twitter.com/ourmachinery" target="_blank">
            <span class="icon-twitter"></span>
        </a>

        <a class="bloglogo" href="http://web.archive.org/web/20180423044956/https://www.facebook.com/Our-Machinery-1828502157362699" target="_blank">
            <span class="icon-facebook"></span>
        </a>    
    
        <a class="bloglogo" href="http://web.archive.org/web/20180423044956/https://instagram.com/ourmachinery" target="_blank">
            <span class="icon-instagram"></span>
        </a>

        <a class="bloglogo" href="http://web.archive.org/web/20180423044956/http://ourmachinery.com/index.xml" target="_blank">
            <span class="icon-feed"></span>
        </a>

        <a class="bloglogo" href="http://web.archive.org/web/20180423044956/mailto:ping@ourmachinery.com" target="_blank">
            <span class="icon-mail"></span>
        </a>
    </footer>
    </div>
    <script type="text/javascript" src="http://web.archive.org/web/20180423044956js_/http://ourmachinery.com/js/jquery.js"></script>
    <script type="text/javascript" src="http://web.archive.org/web/20180423044956js_/http://ourmachinery.com/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="http://web.archive.org/web/20180423044956js_/http://ourmachinery.com/js/index.js"></script>
</body>
</html>

<!--
     FILE ARCHIVED ON 04:49:56 Apr 23, 2018 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 00:53:08 Aug 01, 2022.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 90.948
  exclusion.robots: 0.171
  exclusion.robots.policy: 0.156
  cdx.remote: 0.103
  esindex: 0.015
  LoadShardBlock: 65.071 (3)
  PetaboxLoader3.datanode: 92.273 (4)
  CDXLines.iter: 16.476 (3)
  load_resource: 108.308
  PetaboxLoader3.resolve: 50.651
-->